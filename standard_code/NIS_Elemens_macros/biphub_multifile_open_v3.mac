// BiPHub Multi-File Image Converter V3
// Converts multiple image files using split TIFF mode + auto-reassembly
// Uses YAML config + run_pipeline.exe for robust environment management
// V3 adds support for --split mode with automatic ND2 reassembly

import("NkWindow.dll");
import long NkFile_GetOpenFileName(char * folder, char * name, long name_size, char * filter, long filter_index, char* title, long ofn_flags);

int main() {
    // ALL variable declarations at top (NIS Elements requirement)
    char file_paths[4000];
    char filter_string[200];
    char folder_path[800];
    char current_file[300];
    char full_path[1000];
    char selected_file[1000];
    char basename[1000];
    char split_folder[1000];
    char reassembly_macro[1000];
    char tmp_nd2[1000];
    char temp_folder_path[1000];
    char yaml_content[3000];
    char temp_yaml_path[300];
    char write_yaml_command[3500];
    char run_pipeline_path[300];
    char pipeline_command[400];
    char display_msg[500];
    char python_launcher_script[2000];
    char temp_launcher_path[300];
    char write_launcher_command[2500];
    int folder_len;
    int file_count;
    int current_file_num;
    int pos;
    int name_start;
    int name_len;
    int last_period;
    int wait_cycles;
    int idx;
    int path_len;
    int scene_num;
    long dialog_result;
    
    SetCommandText("BiPHub Multi-File Converter V3 - Select files to convert");
    
    // Build file filter using string literal (confirmed working)
    strcpy(filter_string, "Image Files|*.czi;*.nd2;*.ims;*.tif;*.tiff;*.lsm;*.dv;*.lif;|All Files|*.*|");
    
    // Show multi-file selection dialog
    // OFN_ALLOWMULTISELECT = 0x200 (512) + OFN_EXPLORER = 0x80000 (524288) = 524800
    dialog_result = NkFile_GetOpenFileName("", file_paths, 4000, filter_string, 1, "Select Multiple Image Files for Conversion", 524800);
    
    if (dialog_result == 0) {
        SetCommandText("Conversion cancelled by user");
        return;
    }
    
    // Set run_pipeline.exe path (adjust if needed)
    strcpy(run_pipeline_path, "C:/Users/Nikon Analysis/Documents/biphub/git/run_pipeline/run_pipeline.exe");
    
    // Build temp folder path from run_pipeline path
    // Find last occurrence of "run_pipeline" and truncate after it, then add /temp
    last_period = -1;
    for (idx = 0; idx < strlen(run_pipeline_path); idx = idx + 1) {
        if (run_pipeline_path[idx] == 114) {  // 'r'
            // Check if this is "run_pipeline"
            if ((idx + 12 < strlen(run_pipeline_path)) &&
                (run_pipeline_path[idx + 1] == 117) &&  // 'u'
                (run_pipeline_path[idx + 2] == 110) &&  // 'n'
                (run_pipeline_path[idx + 3] == 95) &&   // '_'
                (run_pipeline_path[idx + 4] == 112) &&  // 'p'
                (run_pipeline_path[idx + 5] == 105) &&  // 'i'
                (run_pipeline_path[idx + 6] == 112) &&  // 'p'
                (run_pipeline_path[idx + 7] == 101) &&  // 'e'
                (run_pipeline_path[idx + 8] == 108) &&  // 'l'
                (run_pipeline_path[idx + 9] == 105) &&  // 'i'
                (run_pipeline_path[idx + 10] == 110) && // 'n'
                (run_pipeline_path[idx + 11] == 101)) { // 'e'
                last_period = idx + 12;  // Position after "run_pipeline"
            }
        }
    }
    
    // Build temp paths
    if (last_period > 0) {
        // Copy up to and including "run_pipeline"
        for (idx = 0; idx < last_period; idx = idx + 1) {
            temp_yaml_path[idx] = run_pipeline_path[idx];
        }
        temp_yaml_path[last_period] = 0;
        strcat(temp_yaml_path, "/temp/nis_converter_temp.yaml");
        
        // Build launcher path
        for (idx = 0; idx < last_period; idx = idx + 1) {
            temp_launcher_path[idx] = run_pipeline_path[idx];
        }
        temp_launcher_path[last_period] = 0;
        strcat(temp_launcher_path, "/temp/nis_pipeline_launcher.py");
    }
    
    
    // Verify run_pipeline.exe exists
    if (!ExistFile(run_pipeline_path)) {
        SetCommandText("ERROR: run_pipeline.exe not found!");
        WaitText(0, "run_pipeline.exe not found at:");
        WaitText(0, run_pipeline_path);
        WaitText(0, "Please update the path in the macro");
        return;
    }
    
    // Parse selected files
    strcpy(folder_path, file_paths);
    folder_len = strlen(folder_path);
    
    // Remove trailing slash from folder_path if present
    if (folder_len > 0) {
        if ((folder_path[folder_len - 1] == 92) || (folder_path[folder_len - 1] == 47)) {
            folder_path[folder_len - 1] = 0;
            folder_len = folder_len - 1;
        }
    }
    
    // Check if single or multiple files selected
    pos = folder_len + 1;
    
    if (file_paths[pos] == 0) {
        // Single file selected - extract folder and filename
        path_len = strlen(file_paths);
        last_period = -1;
        
        // Find last slash
        for (idx = 0; idx < path_len; idx = idx + 1) {
            if (file_paths[idx] == 92) {
                last_period = idx;
            }
            if (file_paths[idx] == 47) {
                last_period = idx;
            }
        }
        
        if (last_period >= 0) {
            // Extract folder
            for (idx = 0; idx < last_period; idx = idx + 1) {
                folder_path[idx] = file_paths[idx];
            }
            folder_path[last_period] = 0;
            
            // Extract filename (skip the slash)
            idx = last_period + 1;
            name_len = 0;
            while (idx < path_len) {
                file_paths[folder_len + 1 + name_len] = file_paths[idx];
                name_len = name_len + 1;
                idx = idx + 1;
            }
            file_paths[folder_len + 1 + name_len] = 0;
            file_paths[folder_len] = 0;
        }
        
        file_count = 1;
        pos = folder_len + 1;
    } else {
        // Multiple files - count them
        file_count = 0;
        idx = folder_len + 1;
        while (idx < 3990) {
            name_start = idx;
            name_len = 0;
            
            while ((file_paths[idx] != 0) && (idx < 3990)) {
                name_len = name_len + 1;
                idx = idx + 1;
            }
            
            if (name_len > 0) {
                file_count = file_count + 1;
                idx = idx + 1;
            } else {
                idx = 4000;
            }
        }
        
        pos = folder_len + 1;
    }
    
    strcpy(display_msg, "Processing ");
    if (file_count < 10) {
        display_msg[11] = 48 + file_count;
        display_msg[12] = 0;
    } else {
        display_msg[11] = 48 + (file_count / 10);
        display_msg[12] = 48 + (file_count % 10);
        display_msg[13] = 0;
    }
    strcat(display_msg, " files...");
    SetCommandText(display_msg);
    
    // Process each file
    current_file_num = 0;
    
    while ((pos > 0) && (pos < 3990)) {
        // Extract filename
        name_start = pos;
        name_len = 0;
        
        while ((file_paths[pos] != 0) && (pos < 3990)) {
            name_len = name_len + 1;
            pos = pos + 1;
        }
        
        if (name_len > 0) {
            // Copy filename
            for (idx = 0; idx < name_len; idx = idx + 1) {
                current_file[idx] = file_paths[name_start + idx];
            }
            current_file[name_len] = 0;
            
            // Build full path
            strcpy(full_path, folder_path);
            strcat(full_path, "/");
            strcat(full_path, current_file);
            strcpy(selected_file, full_path);
            
            // Normalize all backslashes to forward slashes
            for (idx = 0; idx < strlen(selected_file); idx = idx + 1) {
                if (selected_file[idx] == 92) {
                    selected_file[idx] = 47;
                }
            }
            
            current_file_num = current_file_num + 1;
            
            // Display progress
            strcpy(display_msg, "Converting file ");
            if (current_file_num < 10) {
                display_msg[16] = 48 + current_file_num;
                display_msg[17] = 0;
            } else {
                display_msg[16] = 48 + (current_file_num / 10);
                display_msg[17] = 48 + (current_file_num % 10);
                display_msg[18] = 0;
            }
            strcat(display_msg, " of ");
            if (file_count < 10) {
                idx = strlen(display_msg);
                display_msg[idx] = 48 + file_count;
                display_msg[idx + 1] = 0;
            } else {
                idx = strlen(display_msg);
                display_msg[idx] = 48 + (file_count / 10);
                display_msg[idx + 1] = 48 + (file_count % 10);
                display_msg[idx + 2] = 0;
            }
            strcat(display_msg, ": ");
            strcat(display_msg, current_file);
            SetCommandText(display_msg);
            
            pos = pos + 1;
        
            // ==========================================
            // CONVERSION LOGIC USING run_pipeline.exe
            // ==========================================
            
            // Verify input file exists
            if (!ExistFile(selected_file)) {
                SetCommandText("ERROR: File does not exist");
                WaitText(0, selected_file);
                WaitText(0, "Skipping this file");
            } else {
                // Create basename: full path without extension
                path_len = strlen(selected_file);
                last_period = -1;
                
                // Find last period in filename
                for (idx = 0; idx < path_len; idx = idx + 1) {
                    if (selected_file[idx] == 46) {
                        last_period = idx;
                    }
                }
                
                // Copy everything up to (but not including) the last period
                if (last_period >= 0) {
                    for (idx = 0; idx < last_period; idx = idx + 1) {
                        basename[idx] = selected_file[idx];
                    }
                    basename[last_period] = 0;
                } else {
                    strcpy(basename, selected_file);
                }
                
                // Build YAML configuration for run_pipeline
                // Now defined in the beguinning from run_pipeline path

                
                // Extract folder path
                strcpy(temp_folder_path, selected_file);
                for (idx = 0; idx < last_period; idx = idx + 1) {
                    temp_folder_path[idx] = selected_file[idx];
                }
                temp_folder_path[last_period] = 0;
                
                // Find the last slash to get the folder path
                last_period = -1;
                for (idx = 0; idx < strlen(temp_folder_path); idx = idx + 1) {
                    if (temp_folder_path[idx] == 47) {
                        last_period = idx;
                    }
                }
                
                strcpy(write_yaml_command, "with open('");
                strcat(write_yaml_command, temp_yaml_path);
                strcat(write_yaml_command, "', 'w') as f: f.write('''run:\n  - name: convert_to_tif\n    environment: uv:convert-to-tif\n    commands:\n      - python: '%REPO%/standard_code/python/convert_to_tif.py'\n      - --input-search-pattern: ");
                strcat(write_yaml_command, "'");
                strcat(write_yaml_command, selected_file);
                strcat(write_yaml_command, "'\n      - --output-folder: ");
                strcat(write_yaml_command, "'");
                // Add just the folder path
                for (idx = 0; idx < last_period; idx = idx + 1) {
                    write_yaml_command[strlen(write_yaml_command)] = temp_folder_path[idx];
                    write_yaml_command[strlen(write_yaml_command) + 1] = 0;
                }
                strcat(write_yaml_command, "'\n      - --no-parallel\n      - --split\n''')");
                
                Python_RunString(write_yaml_command);
                Wait(0.2);
                
                // Create Python launcher script
                if (ExistFile(temp_yaml_path)) {
                    // temp_launcher_path already built from run_pipeline_path at startup
                    
                    strcpy(python_launcher_script, "import subprocess\nimport sys\n\n");
                    strcat(python_launcher_script, "print('=' * 60)\n");
                    strcat(python_launcher_script, "print('BiPHub Pipeline Converter V3')\n");
                    strcat(python_launcher_script, "print('=' * 60)\n");
                    strcat(python_launcher_script, "print('Executing run_pipeline.exe...')\n");
                    strcat(python_launcher_script, "print('Config: ");
                    strcat(python_launcher_script, temp_yaml_path);
                    strcat(python_launcher_script, "')\n");
                    strcat(python_launcher_script, "print('\\n')\n\n");
                    strcat(python_launcher_script, "result = subprocess.run(['");
                    strcat(python_launcher_script, run_pipeline_path);
                    strcat(python_launcher_script, "', '");
                    strcat(python_launcher_script, temp_yaml_path);
                    strcat(python_launcher_script, "'])\n\n");
                    strcat(python_launcher_script, "print('\\n')\n");
                    strcat(python_launcher_script, "print('=' * 60)\n");
                    strcat(python_launcher_script, "print(f'Pipeline finished with exit code: {result.returncode}')\n");
                    strcat(python_launcher_script, "print('=' * 60)\n");
                    strcat(python_launcher_script, "input('Press Enter to close...')");
                    
                    strcpy(write_launcher_command, "with open('");
                    strcat(write_launcher_command, temp_launcher_path);
                    strcat(write_launcher_command, "', 'w') as f: f.write('''");
                    strcat(write_launcher_command, python_launcher_script);
                    strcat(write_launcher_command, "''')");
                    
                    Python_RunString(write_launcher_command);
                    Wait(0.2);
                    
                    // Execute launcher script
                    if (ExistFile(temp_launcher_path)) {
                        Python_RunFile(temp_launcher_path);
                        Wait(0.1);
                        
                        // With --split mode, look for split folders and reassembly macros
                        // Try single scene first (no suffix)
                        strcpy(split_folder, basename);
                        strcpy(reassembly_macro, split_folder);
                        strcat(reassembly_macro, "/reassemble_to_nd2.mac");
                        
                        SetCommandText(reassembly_macro);
                        WaitText(0, "reassembly_macro"); 
                        
                        if (ExistFile(reassembly_macro)) {
                            // Found reassembly macro for single scene - run it
                            SetCommandText("Running reassembly macro...");
                            RunMacro(reassembly_macro);
                            RunMacro
                            Wait(0.5);
                        } else {
                            // No single scene, try multi-scene folders (_1, _2, etc.)
                            scene_num = 1;
                            while (scene_num <= 100) {
                                strcpy(split_folder, basename);
                                strcat(split_folder, "_");
                                
                                if (scene_num < 10) {
                                    idx = strlen(split_folder);
                                    split_folder[idx] = 48 + scene_num;
                                    split_folder[idx + 1] = 0;
                                } else {
                                    idx = strlen(split_folder);
                                    split_folder[idx] = 48 + (scene_num / 10);
                                    split_folder[idx + 1] = 48 + (scene_num % 10);
                                    split_folder[idx + 2] = 0;
                                }
                                
                                strcpy(reassembly_macro, split_folder);
                                strcat(reassembly_macro, "/reassemble_to_nd2.mac");
                                
                                
                                if (ExistFile(reassembly_macro)) {
                                    SetCommandText("Running reassembly macro for scene...");
                                    RunMacro(reassembly_macro);
                                    Wait(0.5);
                                    scene_num = scene_num + 1;
                                } else {
                                    // No more scenes found
                                    scene_num = 101;
                                }
                            }
                        }
                        
                        DeleteFile(temp_launcher_path);
                    } else {
                        SetCommandText("ERROR: Failed to create launcher script");
                        WaitText(0, "Could not create pipeline launcher");
                    }
                    
                    DeleteFile(temp_yaml_path);
                } else {
                    SetCommandText("ERROR: Failed to create YAML config");
                    WaitText(0, "Could not create configuration file");
                }
            }
        } else {
            pos = 4000;
        }
    }
    
    // Final summary
    SetCommandText("Multi-file conversion completed!");
    strcpy(display_msg, "Processed ");
    if (file_count < 10) {
        display_msg[10] = 48 + file_count;
        display_msg[11] = 0;
    } else {
        display_msg[10] = 48 + (file_count / 10);
        display_msg[11] = 48 + (file_count % 10);
        display_msg[12] = 0;
    }
    strcat(display_msg, " file(s)");
    
    SetCommandText("Multi-file conversion completed!");
    WaitText(2, display_msg);
}
//RunMacro("F:\BIPHUB-OYVIND\test_data\different_fileformats\Apsana_large_czi\29102025_Apsana-04_1\reassemble_to_nd2.mac");
  