// BiPHub Multi-File Image Converter V4
// Opens multiple image files using Fiji headless mode with Bio-Formats
// Then saves them as ND2 format in NIS-Elements
// 
// Key differences from V3:
// - Uses Fiji --headless --run with Jython scripts instead of run_pipeline.exe
// - Leverages Bio-Formats directly through Fiji in headless mode (no GUI)
// - Simpler workflow: exotic format -> Fiji headless Bio-Formats -> NIS-Elements -> ND2
// - More reliable execution with proper headless mode and parameter passing
//
// PREREQUISITES:
// 1. Fiji must be installed with Bio-Formats plugin at:
//    D:/biphub/Program_Files/Fiji/fiji-windows-x64.exe
// 2. Jython script must exist at:
//    D:/biphub/git/run_pipeline/standard_code/NIS_Elemens_macros/ij_bridge_bioformats.py
// 3. Temp folders must be created:
//    - D:/temp/ij_bridge_output/ (for Bio-Formats OME-TIFF output)

import("NkWindow.dll");
import long NkFile_GetOpenFileName(char * folder, char * name, long name_size, char * filter, long filter_index, char* title, long ofn_flags);

int main() {
    // ALL variable declarations at top (NIS Elements requirement)
    char file_paths[4000];
    char filter_string[200];
    char folder_path[800];
    char current_file[300];
    char full_path[1000];
    char selected_file[1000];
    char basename[1000];
    char file_name_only[300];
    char tmp_input_path[1000];
    char tmp_output_path[1000];
    char tmp_nd2[1000];
    char display_msg[500];
    char imagej_script_path[300];
    char jython_params[2000];
    char write_macro_command[2500];
    char input_folder[300];
    char output_folder[300];
    char log_file_path[300];
    char log_command[2500];
    int folder_len;
    int file_count;
    int current_file_num;
    int pos;
    int name_start;
    int name_len;
    int last_period;
    int last_slash;
    int idx;
    int path_len;
    int scene_num;
    int wait_cycles;
    long dialog_result;
    
    SetCommandText("BiPHub Multi-File Converter V4 - ImageJ Bridge");
    
    // Set up log file path (same directory as macro)
    strcpy(log_file_path, "D:/biphub/git/run_pipeline/standard_code/NIS_Elemens_macros/biphub_multifile_open_v4.log");
    
    // Initialize log file
    strcpy(log_command, "import datetime; f = open('");
    strcat(log_command, log_file_path);
    strcat(log_command, "', 'w'); f.write('=== BiPHub Multi-File Converter V4 Log ===\\n'); f.write(f'Started: {datetime.datetime.now()}\\n\\n'); f.close()");
    Python_RunString(log_command);
    
    // Set up ImageJ Bridge paths
    strcpy(output_folder, "D:/temp/ij_bridge_output");
    strcpy(imagej_script_path, "D:/temp/ij_bridge_bioformats.py");
    
    // Log setup
    strcpy(log_command, "f = open('");
    strcat(log_command, log_file_path);
    strcat(log_command, "', 'a'); f.write('Output folder: ");
    strcat(log_command, output_folder);
    strcat(log_command, "\\\\n'); f.write('Jython script: ");
    strcat(log_command, imagej_script_path);
    strcat(log_command, "\\\\n\\\\n'); f.close()");
    Python_RunString(log_command);
    
    // Build file filter
    strcpy(filter_string, "Image Files|*.czi;*.nd2;*.ims;*.tif;*.tiff;*.lsm;*.dv;*.lif;*.oib;*.oif;|All Files|*.*|");
    
    // Show multi-file selection dialog
    dialog_result = NkFile_GetOpenFileName("", file_paths, 4000, filter_string, 1, "Select Multiple Image Files for Conversion", 524800);
    
    if (dialog_result == 0) {
        SetCommandText("Conversion cancelled by user");
        strcpy(log_command, "f = open('");
        strcat(log_command, log_file_path);
        strcat(log_command, "', 'a'); f.write('User cancelled file selection\\n'); f.close()");
        Python_RunString(log_command);
        return;
    }
    
    // Parse selected files
    strcpy(folder_path, file_paths);
    folder_len = strlen(folder_path);
    
    // Remove trailing slash from folder_path if present
    if (folder_len > 0) {
        if ((folder_path[folder_len - 1] == 92) || (folder_path[folder_len - 1] == 47)) {
            folder_path[folder_len - 1] = 0;
            folder_len = folder_len - 1;
        }
    }
    
    // Check if single or multiple files selected
    pos = folder_len + 1;
    
    if (file_paths[pos] == 0) {
        // Single file selected - extract folder and filename
        path_len = strlen(file_paths);
        last_slash = -1;
        
        // Find last slash
        for (idx = 0; idx < path_len; idx = idx + 1) {
            if (file_paths[idx] == 92) {
                last_slash = idx;
            }
            if (file_paths[idx] == 47) {
                last_slash = idx;
            }
        }
        
        if (last_slash >= 0) {
            // Extract folder
            for (idx = 0; idx < last_slash; idx = idx + 1) {
                folder_path[idx] = file_paths[idx];
            }
            folder_path[last_slash] = 0;
            
            // Extract filename (skip the slash)
            idx = last_slash + 1;
            name_len = 0;
            while (idx < path_len) {
                file_paths[folder_len + 1 + name_len] = file_paths[idx];
                name_len = name_len + 1;
                idx = idx + 1;
            }
            file_paths[folder_len + 1 + name_len] = 0;
            file_paths[folder_len] = 0;
        }
        
        file_count = 1;
        pos = folder_len + 1;
    } else {
        // Multiple files - count them
        file_count = 0;
        idx = folder_len + 1;
        while (idx < 3990) {
            name_start = idx;
            name_len = 0;
            
            while ((file_paths[idx] != 0) && (idx < 3990)) {
                name_len = name_len + 1;
                idx = idx + 1;
            }
            
            if (name_len > 0) {
                file_count = file_count + 1;
                idx = idx + 1;
            } else {
                idx = 4000;
            }
        }
        
        pos = folder_len + 1;
    }
    
    strcpy(display_msg, "Processing ");
    if (file_count < 10) {
        display_msg[11] = 48 + file_count;
        display_msg[12] = 0;
    } else {
        display_msg[11] = 48 + (file_count / 10);
        display_msg[12] = 48 + (file_count % 10);
        display_msg[13] = 0;
    }
    strcat(display_msg, " files...");
    SetCommandText(display_msg);
    
    // Log file count
    strcpy(log_command, "f = open('");
    strcat(log_command, log_file_path);
    strcat(log_command, "', 'a'); f.write(f'Found {");
    if (file_count < 10) {
        log_command[strlen(log_command)] = 48 + file_count;
        log_command[strlen(log_command)] = 0;
    } else {
        log_command[strlen(log_command)] = 48 + (file_count / 10);
        log_command[strlen(log_command)] = 48 + (file_count % 10);
        log_command[strlen(log_command)] = 0;
    }
    strcat(log_command, "} file(s) for processing\\\\n\\\\n'); f.close()");
    Python_RunString(log_command);
    
    // Process each file
    current_file_num = 0;
    
    while ((pos > 0) && (pos < 3990)) {
        // Extract filename
        name_start = pos;
        name_len = 0;
        
        while ((file_paths[pos] != 0) && (pos < 3990)) {
            name_len = name_len + 1;
            pos = pos + 1;
        }
        
        if (name_len > 0) {
            // Copy filename
            for (idx = 0; idx < name_len; idx = idx + 1) {
                current_file[idx] = file_paths[name_start + idx];
            }
            current_file[name_len] = 0;
            
            // Build full path
            strcpy(full_path, folder_path);
            strcat(full_path, "/");
            strcat(full_path, current_file);
            strcpy(selected_file, full_path);
            
            // Normalize all backslashes to forward slashes
            for (idx = 0; idx < strlen(selected_file); idx = idx + 1) {
                if (selected_file[idx] == 92) {
                    selected_file[idx] = 47;
                }
            }
            
            current_file_num = current_file_num + 1;
            
            // Display progress
            strcpy(display_msg, "Converting file ");
            if (current_file_num < 10) {
                display_msg[16] = 48 + current_file_num;
                display_msg[17] = 0;
            } else {
                display_msg[16] = 48 + (current_file_num / 10);
                display_msg[17] = 48 + (current_file_num % 10);
                display_msg[18] = 0;
            }
            strcat(display_msg, " of ");
            if (file_count < 10) {
                idx = strlen(display_msg);
                display_msg[idx] = 48 + file_count;
                display_msg[idx + 1] = 0;
            } else {
                idx = strlen(display_msg);
                display_msg[idx] = 48 + (file_count / 10);
                display_msg[idx + 1] = 48 + (file_count % 10);
                display_msg[idx + 2] = 0;
            }
            strcat(display_msg, ": ");
            strcat(display_msg, current_file);
            SetCommandText(display_msg);
            
            // Log current file
            strcpy(log_command, "f = open('");
            strcat(log_command, log_file_path);
            strcat(log_command, "', 'a'); f.write('--- File ");
            if (current_file_num < 10) {
                log_command[strlen(log_command)] = 48 + current_file_num;
                log_command[strlen(log_command)] = 0;
            } else {
                log_command[strlen(log_command)] = 48 + (current_file_num / 10);
                log_command[strlen(log_command)] = 48 + (current_file_num % 10);
                log_command[strlen(log_command)] = 0;
            }
            strcat(log_command, " ---\\\\n'); f.write('Path: ");
            strcat(log_command, selected_file);
            strcat(log_command, "\\\\n'); f.close()");
            Python_RunString(log_command);
            
            pos = pos + 1;
        
            // ==========================================
            // CONVERSION LOGIC USING ImageJ Bridge
            // ==========================================
            
            // Verify input file exists
            if (!ExistFile(selected_file)) {
                SetCommandText("ERROR: File does not exist");
                strcpy(log_command, "f = open('");
                strcat(log_command, log_file_path);
                strcat(log_command, "', 'a'); f.write('ERROR: File does not exist\\\\n'); f.close()");
                Python_RunString(log_command);
                WaitText(0, selected_file);
                WaitText(0, "Skipping this file");
            } else {
                // Extract filename without extension for basename
                path_len = strlen(selected_file);
                last_period = -1;
                last_slash = -1;
                
                // Find last period and last slash
                for (idx = 0; idx < path_len; idx = idx + 1) {
                    if (selected_file[idx] == 46) {
                        last_period = idx;
                    }
                    if ((selected_file[idx] == 92) || (selected_file[idx] == 47)) {
                        last_slash = idx;
                    }
                }
                
                // Extract filename only (without path)
                if (last_slash >= 0) {
                    idx = last_slash + 1;
                    name_len = 0;
                    while (idx < path_len) {
                        file_name_only[name_len] = selected_file[idx];
                        name_len = name_len + 1;
                        idx = idx + 1;
                    }
                    file_name_only[name_len] = 0;
                } else {
                    strcpy(file_name_only, selected_file);
                }
                
                // Create basename without extension
                if (last_period >= 0) {
                    name_len = 0;
                    idx = last_slash + 1;
                    while (idx < last_period) {
                        basename[name_len] = selected_file[idx];
                        name_len = name_len + 1;
                        idx = idx + 1;
                    }
                    basename[name_len] = 0;
                } else {
                    strcpy(basename, file_name_only);
                }
                
                // Build expected output path for first file in sequence
                // Bio-Formats will create: basename_Z0_C0.ome.tif, basename_Z0_C1.ome.tif, etc.
                strcpy(tmp_output_path, output_folder);
                strcat(tmp_output_path, "/");
                strcat(tmp_output_path, basename);
                strcat(tmp_output_path, ".ome.tif");
                
                // Build Jython parameters for this file
                // Format for Windows: "filePath='path', outputPath='path', outputFolder='path'"
                strcpy(jython_params, "filePath='");
                strcat(jython_params, selected_file);
                strcat(jython_params, "', outputPath='");
                strcat(jython_params, tmp_output_path);
                strcat(jython_params, "', outputFolder='");
                strcat(jython_params, output_folder);
                strcat(jython_params, "'");
                
                // Use ImageJ Bridge to process the file
                // This will:
                // 1. Run ImageJ/Fiji
                // 2. Execute the macro which reads the marker, opens file with Bio-Formats
                // 3. Save as TIFF to output folder
                // 4. Close ImageJ
                
                SetCommandText("Opening with ImageJ Bio-Formats...");
                
                // Log ImageJ execution
                strcpy(log_command, "f = open('");
                strcat(log_command, log_file_path);
                strcat(log_command, "', 'a'); f.write('Processing file: ");
                strcat(log_command, selected_file);
                strcat(log_command, "\\\\n'); f.write('Executing Fiji headless...\\\\n'); f.write('Expected output: ");
                strcat(log_command, tmp_output_path);
                strcat(log_command, "\\\\n'); f.close()");
                Python_RunString(log_command);
                
                // Execute Fiji in headless mode with Jython script
                strcpy(write_macro_command, "import subprocess; subprocess.Popen(['D:/biphub/Program_Files/Fiji/fiji-windows-x64.exe', '--headless', '--run', '");
                strcat(write_macro_command, imagej_script_path);
                strcat(write_macro_command, "', '");
                strcat(write_macro_command, jython_params);
                strcat(write_macro_command, "'])");
                
                Python_RunString(write_macro_command);
                Wait(1.0);
                
                // Log Fiji headless launched
                strcpy(log_command, "f = open('");
                strcat(log_command, log_file_path);
                strcat(log_command, "', 'a'); f.write('Fiji headless launched, waiting for done marker...\\\\n'); f.close()");
                Python_RunString(log_command);
                
                // Build path to done marker file
                strcpy(tmp_input_path, output_folder);
                strcat(tmp_input_path, "/done.txt");
                
                // Wait for done.txt marker file (ImageJ creates this after export completes)
                wait_cycles = 0;
                while (!ExistFile(tmp_input_path) && (wait_cycles < 300)) {
                    Wait(0.5);
                    wait_cycles = wait_cycles + 1;
                }
                
                if (ExistFile(tmp_input_path)) {
                    // Log success
                    strcpy(log_command, "f = open('");
                    strcat(log_command, log_file_path);
                    strcat(log_command, "', 'a'); f.write('ImageJ conversion successful\\\\n'); f.close()");
                    Python_RunString(log_command);
                    
                    // Delete done marker file
                    DeleteFile(tmp_input_path);
                    
                    // Build path to first OME-TIFF file
                    strcpy(tmp_input_path, output_folder);
                    strcat(tmp_input_path, "/");
                    strcat(tmp_input_path, basename);
                    strcat(tmp_input_path, "_Z0_C0.ome.tif");
                    
                    // Open first file - NIS-Elements auto-detects and opens entire sequence
                    // This will automatically merge all Z#_C#.ome.tif files into proper TCZYX stack
                    OpenDocument(tmp_input_path, 0);
                    Wait(0.5);
                    
                    // Save as ND2 in same folder as original file
                    strcpy(tmp_nd2, folder_path);
                    strcat(tmp_nd2, "/");
                    strcat(tmp_nd2, basename);
                    strcat(tmp_nd2, ".nd2");
                    
                    ImageSaveAs(tmp_nd2, 14, 0);
                    
                    // Log ND2 save
                    strcpy(log_command, "f = open('");
                    strcat(log_command, log_file_path);
                    strcat(log_command, "', 'a'); f.write('Saved as ND2: ");
                    strcat(log_command, tmp_nd2);
                    strcat(log_command, "\\\\n'); f.close()");
                    Python_RunString(log_command);
                    
                    CloseAllDocuments(2);
                    
                    // Clean up all temporary OME-TIFF files in output folder
                    // Bio-Formats creates multiple files (basename_Z#_C#.ome.tif)
                    // Use forward slashes for Python compatibility
                    strcpy(log_command, "import os, glob; pattern = r'");
                    strcat(log_command, output_folder);
                    strcat(log_command, "/");
                    strcat(log_command, basename);
                    strcat(log_command, "_Z*_C*.ome.tif'.replace('\\\\\\\\', '/'); files = glob.glob(pattern); removed = [os.remove(f) for f in files]; print(f'Cleaned up {len(files)} temp files')");
                    Python_RunString(log_command);
                    Wait(0.2);
                    
                    SetCommandText("Conversion successful!");
                } else {
                    SetCommandText("ERROR: Fiji headless conversion timeout");
                    strcpy(log_command, "f = open('");
                    strcat(log_command, log_file_path);
                    strcat(log_command, "', 'a'); f.write('ERROR: Fiji headless conversion timeout after ");
                    if (wait_cycles < 10) {
                        log_command[strlen(log_command)] = 48 + wait_cycles;
                        log_command[strlen(log_command)] = 0;
                    } else {
                        log_command[strlen(log_command)] = 48 + (wait_cycles / 10);
                        log_command[strlen(log_command)] = 48 + (wait_cycles % 10);
                        log_command[strlen(log_command)] = 0;
                    }
                    strcat(log_command, " cycles\\\\n'); f.close()");
                    Python_RunString(log_command);
                    WaitText(0, "File may be too large or Fiji not configured");
                    WaitText(0, "Expected output:");
                    WaitText(0, tmp_output_path);
                }
            }
        } else {
            pos = 4000;
        }
    }
    
    // Final summary
    SetCommandText("Multi-file conversion completed!");
    strcpy(display_msg, "Processed ");
    if (file_count < 10) {
        display_msg[10] = 48 + file_count;
        display_msg[11] = 0;
    } else {
        display_msg[10] = 48 + (file_count / 10);
        display_msg[11] = 48 + (file_count % 10);
        display_msg[12] = 0;
    }
    strcat(display_msg, " file(s)");
    
    // Log completion
    strcpy(log_command, "import datetime; f = open('");
    strcat(log_command, log_file_path);
    strcat(log_command, "', 'a'); f.write(f'\\\\n=== Completed: {datetime.datetime.now()} ===\\\\n'); f.close()");
    Python_RunString(log_command);
    
    WaitText(2, display_msg);
}
  